---
title: "Write Customers & Sales to Production Database"
date: '`r strftime(Sys.time(), format = "%B %d, %Y")`'
output: 
    html_document:
        toc: true
        toc_float: true
        code_folding: show
---

**Notes**


```{r setup, message=FALSE}
library(tidyverse)
library(readxl)
library(salic)
library(lubridate)
knitr::opts_chunk$set(comment = NA)
```

*Guidelines: Produce a standardized anonymized database, excluding data that isn't needed to produce a license history table.*


## Load

### License Table

*Guidelines: Note that the "lic" table is used here for identifying residency in the production sale table*

```{r}
lic <- read_excel("../data/1-prep-license-data/license-types-prepped.xlsx") %>%
    select(lic_id, type, lic_res)
glimpse(lic)
```


### Customers & Sales

```{r}
f <- "../../../../../Data-sensitive/Data-Dashboards/__state__/standard.sqlite3"
db_standard <- src_sqlite(f)

cust <- tbl(db_standard, "cust") %>%
    select(-first, -last) %>%
    collect()
glimpse(cust)
```

```{r}
sale <- tbl(db_standard, "sale") %>%
    collect() %>%
    left_join(lic, by = "lic_id")
glimpse(sale)
```


## Prep Sales

### Transaction Month

*Guidelines: The standardized transaction month is used in dashboard production.*

*The month_range argument is used to reign in weird values (outside of the normal range). Determining the normal range might take some work.*

```{r}
# find the appropriate range for recoding a standard month
samp <- sale %>%
    sample_n(100000) %>% # bigger samples will give more complete coverage
    salic::recode_month(month_range = -30:30) # start with a ridiculous possible range

# counts by month-year
x <- samp %>%
    count(type, year, month)

x %>%
    ggplot(aes(month, n, fill = type)) +
    geom_col() +
    facet_wrap(~ year)
```

```{r}
# apply recoding
sale <- sale %>%
    salic::recode_month(0:13) %>%
    mutate(month = as.integer(month))
```


## Prep Customers

### Drop Customers Not in Sales

*Guidelines: Keeping the production data as streamined as possible*

```{r}
cust <- cust %>%
    semi_join(sale, by = "cust_id")
nrow(cust)
```


### Birth year

*Guidelines: Keeping date-of-birth out of standardized data so that it is more anonymous*

```{r}
cust <- cust %>%
    mutate(birth_year = year(ymd(dob)))

# check
sample_n(cust, 5) %>% select(dob, birth_year)
```


## Identify Sales Residency

*Guidelines: Residency is identified preferably with (1) by license type, then (2) other sales by the same customer, and finally (3) mailing state. This sequence usually will identify residency for close to 100% of sales.*

### 1. License Type

```{r}
# check
sale %>%
    count(lic_res) %>% 
    mutate(pct = n / sum(n) * 100)
```

### 2. Other Sales

*Guidelines: Choose the most recent identified residency*

```{r}
# this code isn't elegant, but it works

# temporarily separate sales without residency
sale_without_res <- sale %>%
    filter(is.na(lic_res))

# get the most recent identified residency
all_recent_res <- sale %>%
    filter(!is.na(lic_res)) %>%
    select(cust_id, year_res = year, recent_res = lic_res) %>%
    distinct()

# identify most recent for the unknowns
recent_res <- sale_without_res %>%
    inner_join(all_recent_res, by = "cust_id") %>%
    mutate(year_diff = abs(year - year_res)) %>%
    # prefer most recent year, for ties prefer residents (1) over nonresidents (0)
    arrange(raw_sale_id, year_diff, desc(recent_res)) %>%
    group_by(raw_sale_id) %>%
    slice(1L) %>%
    ungroup()

# stack back to sales table
sale <- sale %>%
    anti_join(recent_res, by = "raw_sale_id") %>% # first drop those newly identified
    bind_rows(recent_res)
rm(all_recent_res, recent_res, sale_without_res)

# check
sale %>%
    count(lic_res, recent_res) %>% 
    mutate(pct = n / sum(n) * 100)
```


### 3. Address State

*Guidelines: Choose remaining based on address (represented by `cust_res`)*

```{r}
sale <- sale %>%
    left_join(select(cust, cust_id, cust_res), by = "cust_id") %>%
    mutate(
        res = ifelse(!is.na(lic_res), lic_res, 
                     ifelse(!is.na(recent_res), recent_res, cust_res)),
        # for summarization
        res_id = ifelse(!is.na(lic_res), "lic_res",  
                        ifelse(!is.na(recent_res), "recent_res", 
                               ifelse(!is.na(cust_res), "cust_res", NA))) %>%
            factor(levels = c("lic_res", "recent_res", "cust_res"))
    )

# check residency coding
sale %>%
    count(res_id) %>%
    mutate(pct = round(n / sum(n) * 100, 1))

# check coding heirarchy (lic_res, recent_res, cust_res)
sale %>%
    count(res_id, lic_res, recent_res, cust_res) %>% 
    data.frame()
```


## Finalize Tables

```{r}
cust <- cust %>% 
    select(cust_id, sex, birth_year, cust_res, raw_cust_id, source_cust) %>%
    mutate(birth_year = as.integer(birth_year))
glimpse(cust)
```

```{r}
sale <- sale %>%
    select(cust_id, lic_id, year, month, dot, start_date, end_date, revenue,
           res, raw_sale_id, source_sale) %>%
    mutate(lic_id = as.integer(lic_id))
glimpse(sale)
```


## Write to Sqlite

```{r}
f <- "../../../../../Data-production/Data-Dashboards/__state__/lic.sqlite3"
db_lic <- src_sqlite(f, create = TRUE)

copy_to(db_lic, cust, temporary = FALSE)
copy_to(db_lic, sale, temporary = FALSE)
```


```{r}
sessionInfo()
```
