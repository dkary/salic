---
title: "Make dashboard tables for Tableau Input (by priv)"
date: '`r strftime(Sys.time(), format = "%B %d, %Y")`'
output: 
    html_document:
        toc: true
        toc_float: true
        code_folding: hide
params:
    priv_nm: trout_res  # (fish, hunt, all_sports) or (deer, trout, etc.)
    priv_ref: fish  # (NONE, fish, hunt, all_sports) > denominator for privilege rate
    yrs: 2008:2017  # (first_year:last_year)
    res_type: res # (NONE, res, nonres)
    res_filter: NONE # (NONE, res, nonres)
    out_dir: "../data/4-dashboard-results"  # directory for output RData (may vary by state)
---

```{r setup, message=FALSE}
library(tidyverse)
library(stringr)
library(salic)
source("func.R")
options(scipen = 999)
knitr::opts_chunk$set(comment = NA)
```

## Params

```{r}
# make a vector of years from the params$yrs input
get_range <- function(x) {
    y <- stringr::str_split_fixed(x, ":", 2)
    `:`(y[1], y[2])
}
yrs <- get_range(params$yrs)
```

```{r}
tribble(
    ~param, ~value,
    "priv_nm", params$priv_nm,
    "priv_ref", params$priv_ref,
    "yrs", params$yrs,
    "res_type", params$res_type,
    "res_filter", params$res_filter,
    "out_dir", params$out_dir
) %>% DT::datatable()
```

## Load

### Population

*For estimating participation rates*

```{r}
f <- "../../../../../Data-production/Data-Dashboards/_Shared/census.sqlite3"
db_census <- src_sqlite(f)

pop_county <- tbl(db_census, "pop_acs") %>% 
    filter(state_abbrev == "VA") %>%
    collect() %>%
    # collapse to 7 age categories
    group_by(county_fips, year, sex, age) %>%
    summarise(pop = sum(pop)) %>%
    ungroup()

# join county names
county_fips <- tbl(db_census, "county_fips") %>%
    select(county_fips, county = county_name) %>%
    collect()
pop_county <- pop_county %>%
    left_join(county_fips, by = "county_fips")
glimpse(pop_county)
```

### Permissions

```{r}
f <- "../../../../../Data-production/Data-Dashboards/__state__/license.sqlite3"
db_license <- src_sqlite(f)

# temporarily pull customers for joining customer info
cust <- tbl(db_license, "cust") %>%
    select(cust_id, county_fips, sex, birth_year) %>%
    collect() %>%
    left_join(county_fips, by = "county_fips")

# pull permissions from license history
f <- "../../../../../Data-production/Data-Dashboards/__state__/history.sqlite3"
db_history <- src_sqlite(f)

priv <- tbl(db_history, params$priv_nm) %>% 
    select(cust_id, year, res, lapse, R3) %>%
    collect() %>%
    filter(year %in% yrs) %>%
    left_join(cust, by = "cust_id")
rm(cust, county_fips)
glimpse(priv)
```

### Sales

*For showing sales by month*

```{r}
# identify relevant sales
permission <- tbl(db_license, "permission") %>% 
    collect() %>%
    filter(permission == params$priv_nm)

# get sales based on permission filter
# different condition needed if there is only one license ID in the priv
if (length(permission$lic_id) == 1) {
    sale <- tbl(db_license, "sale") %>% filter(lic_id == permission$lic_id)
} else {
    sale <- tbl(db_license, "sale") %>% filter(lic_id %in% permission$lic_id)
}
sale <- select(sale, cust_id, year, month) %>% 
    collect()
rm(permission, db_census, db_history, db_license)
glimpse(sale)
```

## Prep

### Residency-Specific Filtering

*This only applies to overall types that need to be used for residency-specific privilege rates*

```{r}
if (params$res_filter == "res") {
    priv <- filter(priv, res == 1)
    sale <- semi_join(sale, priv, by = "cust_id")
    count(priv, res)
}
if (params$res_filter == "nonres") {
    priv <- filter(priv, res == 0)
    sale <- semi_join(sale, priv, by = "cust_id")
    count(priv, res)
}
```


### Residency-Specific Recoding

*This only applies to privileges with a defined residency type (which might not have been completely specified in the data preparation phase)*

```{r}
if (params$res_type == "res") {
    priv$res <- 1
    count(priv, res)
}
if (params$res_type == "nonres") {
    priv$res <- 0
    count(priv, res)
}
```

### Calculate Age Categories 

```{r}
priv <- salic::recode_agecat(priv)
sample_n(priv, 10) %>% select(year, birth_year, age_year, age, agecat) %>% data.frame()
```

### Label Demographic Categories

*So the output will show category names instead of codes*

```{r}
priv <- select(priv, -birth_year, -age_year, -age) %>%
    rename(age = agecat) %>%
    df_factor_sex() %>%
    df_factor_res() %>%
    df_factor_R3()

pop_county <- pop_county %>%
    df_factor_sex() %>%
    df_factor_age()
```

## Results

### Population

```{r}
pop <- list()

pop[["tot"]] <- group_by(pop_county, year) %>%
    summarise(pop = sum(pop)) 

pop[["sex"]] <- group_by(pop_county, year, sex) %>%
    summarise(pop = sum(pop)) %>% ungroup() %>%
    format_grp("gender", "sex")

pop[["age"]] <- group_by(pop_county, year, age) %>%
    summarise(pop = sum(pop)) %>% ungroup() %>%
    format_grp("age")

pop[["county"]] <- group_by(pop_county, year, county) %>%
    summarise(pop = sum(pop)) %>% ungroup() %>%
    format_grp("county")

rm(pop_county)
```

### Participants

- Do some work on checking and visualization
    + checking > see est_total_check() and notes below
    + visualization > include an interactive ggplot showing trends (like dashboard)
    + (see WI dive code in producing a nice faceted line plot)
    + (use group: [tot, sex, ...] & compare: [down, across] for widgets)

- Future: Maybe include a warning based on pct_diff threshold
    + also a count of missing values would be useful (shows something similar), but a more direct measurement of the amount of estimation needed

```{r}
# total counts - used for correcting for missing values in grouping variables
tot <- count(priv, year)
tot_residency <- count(priv, year, res) %>%
    group_by(year) %>%
    est_total("res", tot)

part <- list()
part[["tot"]] <- format_metric(tot) %>% 
    mutate(segment = "All", category = "All")

part[["sex"]] <- count(priv, year, sex) %>%
    group_by(year) %>%
    est_total("sex", tot) %>% 
    format_metric() %>% format_grp("gender", "sex")

part[["age"]] <- count(priv, year, age) %>%
    group_by(year) %>%
    est_total("age", tot) %>%
    format_metric() %>% format_grp("age")

part[["res"]] <- format_metric(tot_residency) %>% 
    format_grp("Residency", "res")


# est_total_check <- function(x) {
#     missing <- filter(x, !is.na(n.x)) %>%
#         group_by(year, segment) %>%
#         summarise(total = sum(value), valid = sum(n.x)) %>%
#         ungroup %>% mutate(
#             missing = total - valid,
#             pct_missing = round(missing / total * 100, 2)
#         )
#     select(missing, year, segment, missing) %>% 
#         spread(year, missing) %>%
#     select(missing, year, segment, pct_missing) %>% 
#         spread(year, pct_missing) 
# }

# display how much needed to be estimated for groups (because of missing values)
# (there must be a more clear way to explain this)
# (why does pct_diff provide a larger value??? > and better to call pct_missing?)
# bind_rows(part) %>% est_total_check()
```

```{r}
### Residents Only (for by-county breakouts & participation rates)
if (params$res_type != "nonres" & params$res_filter != "nonres") {
    priv_res <- filter(priv, res == "Resident")
    tot_res <- filter(tot_residency, res == "Resident") %>% select(-n.x)
    
    part_res <- list()
    part_res[["county"]] <- priv_res %>%
        filter(year %in% c(yrs[length(yrs)])) %>%
        count(year, county) %>%
        group_by(year) %>%
        est_total("county", tot_res) %>%
        format_metric() %>% format_grp("county")
    
    # age & sex - for calculating participation rates
    # these won't be included in final dashboard table
    part_res[["sex"]] <- count(priv_res, year, sex) %>%
        group_by(year) %>%
        est_total("sex", tot_res) %>% 
        format_metric() %>% format_grp("gender", "sex")
    
    part_res[["age"]] <- count(priv_res, year, age) %>%
        group_by(year) %>%
        est_total("age", tot_res) %>%
        format_metric() %>% format_grp("age")
    
    # stack for dashboard
    part_tbl <- bind_rows(part) %>% bind_rows(part_res[["county"]]) %>%
        # round participants to nearest whole number, since fractions don't make sense
        mutate(value = round(value, digits = 0))
    rm(tot, tot_res, tot_residency)
    
    # check percent missing
    # to insure nothing odd in estimating total for groups
    # bind_rows(part_tbl, part_res[["sex"]]) %>% bind_rows(part_res[["age"]]) %>%
    #     est_total_check() %>% DT::datatable()
} else {
    part_tbl <- bind_rows(part)
}
```

### Participation Rate

- Participants / Resident Population
- Only estimated for overall types (priv_ref == NONE)

```{r}
if (params$priv_ref == "NONE" & params$res_filter != "nonres") {
    rate <- list()
    
    # overall permissions
    rate[["sex"]] <- part_res[["sex"]] %>%
        select(year, segment, category, part = value) %>%
        left_join(pop[["sex"]], by = c("year", "segment", "category")) %>%
        mutate(value = part / pop, metric = "participation rate")
    
    rate[["age"]] <- part_res[["age"]] %>%
        select(year, segment, category, part = value) %>%
        left_join(pop[["age"]], by = c("year", "segment", "category")) %>%
        mutate(value = part / pop, metric = "participation rate")
    
    rate[["county"]] <- part_res[["county"]] %>%
        select(year, segment, category, part = value) %>%
        left_join(pop[["county"]], by = c("year", "segment", "category")) %>%
        mutate(value = part / pop, metric = "participation rate")
    
    # overall rate is included twice (which is weird, but helps on the tableau end)
    rate[["res"]] <- part[["res"]] %>%
        select(year, segment, category, part = value) %>%
        left_join(pop[["tot"]], by = "year") %>%
        # nonresident is set at zero for tableau dashboard
        mutate(value = part / pop, metric = "participation rate",
               value = ifelse(category == "Nonresident", 0, value))
    
    rate[["tot"]] <- filter(rate[["res"]], category == "Resident") %>%
        select(-segment, -category) %>%
        mutate(segment = "All", "category" = "All")
    
    rate_tbl <- bind_rows(rate)
    group_by(rate_tbl, segment) %>% summarise(max_rate = max(value))
}
```

### Privilege Rate

- Participants / Parent Permission Participants
- Only estimated for privilege types (priv_ref != NONE)

```{r}
if (params$priv_ref != "NONE") {
    rate <- list()
    
    # load and prep target permission participation estimates
    if (params$res_type == "nonres") {
        load(file.path(params$out_dir, "part", paste0(params$priv_ref, "-nonres-part.RDATA")))
    } else if (params$res_type == "res") {
        load(file.path(params$out_dir, "part", paste0(params$priv_ref, "-res-part.RDATA")))
    } else {
        load(file.path(params$out_dir, "part", paste0(params$priv_ref, "-part.RDATA")))
    }
    
    part_ref[["sex"]] <- select(part_ref[["sex"]], year, segment, category, all = value)
    part_ref[["age"]] <- select(part_ref[["age"]], year, segment, category, all = value)
    part_ref[["res"]] <- select(part_ref[["res"]], year, segment, category, all = value)
    
    rate[["sex"]] <- part[["sex"]] %>%
        select(year, segment, category, priv = value) %>%
        left_join(part_ref[["sex"]], by = c("year", "segment", "category")) %>%
        mutate(value = priv / all, metric = "participation rate")
    
    rate[["age"]] <- part[["age"]] %>%
        select(year, segment, category, priv = value) %>%
        left_join(part_ref[["age"]], by = c("year", "segment", "category")) %>%
        mutate(value = priv / all, metric = "participation rate")
    
    # this will be partial for resident-only privileges, could cause a Tableau issue
    rate[["res"]] <- part[["res"]] %>%
        select(year, segment, category, priv = value) %>%
        left_join(part_ref[["res"]], by = c("year", "segment", "category")) %>%
        mutate(value = priv / all, metric = "participation rate")
    
    if (params$res_type != "nonres") {
        part_ref[["county"]] <- select(part_ref[["county"]], year, segment, 
                                       category, all = value)
        rate[["county"]] <- part_res[["county"]] %>%
            select(year, segment, category, priv = value) %>%
            left_join(part_ref[["county"]], by = c("year", "segment", "category")) %>%
            mutate(value = priv / all, metric = "participation rate")
        
        rate[["tot"]] <- filter(rate[["res"]], category == "Resident") %>%
            select(-segment, -category) %>%
            mutate(segment = "All", "category" = "All")
    } else {
        rate[["tot"]] <- filter(rate[["res"]], category == "Nonresident") %>%
            select(-segment, -category) %>%
            mutate(segment = "All", "category" = "All")
    }
    rate_tbl <- bind_rows(rate)
    group_by(rate_tbl, segment) %>% summarise(max_rate = max(value))
}
```

### Recruits

- Mostly the same as Participation code above, with some differences
    + different `format_metric()`
    + filter: `priv_new` vs. `priv`
    + resident-specific is only needed for counties (since rate is not calculated for these)

```{r}
# check - should only be missing for the first 5 years
count(priv, R3, year) %>% spread(year, n)
priv_new <- filter(priv, !is.na(R3), R3 == "Recruit")

# only run if there are recruits available
run_recruit <- nrow(priv_new) > 0
if (run_recruit) {
    # total counts - used for correcting for missing values in grouping variables
    tot <- count(priv_new, year)
    tot_residency <- count(priv_new, year, res) %>%
        group_by(year) %>%
        est_total("res", tot)
    
    recruit <- list()
    recruit[["tot"]] <- format_metric(tot, "participants - recruited") %>% 
        mutate(segment = "All", category = "All")
    
    recruit[["sex"]] <- count(priv_new, year, sex) %>%
        group_by(year) %>%
        est_total("sex", tot) %>% 
        format_metric("participants - recruited") %>% format_grp("gender", "sex")
    
    recruit[["age"]] <- count(priv_new, year, age) %>%
        group_by(year) %>%
        est_total("age", tot) %>%
        format_metric("participants - recruited") %>% format_grp("age")
    
    recruit[["res"]] <- format_metric(tot_residency, "participants - recruited") %>% 
        format_grp("Residency", "res")
    
    ### Residents Only (for by-county breakouts)
    priv_new_res <- filter(priv_new, res == "Resident")
    tot_res <- filter(tot_residency, res == "Resident") %>% select(-n.x)
    
    if (params$res_type != "nonres" & params$res_filter != "nonres") {
        recruit[["county"]] <- priv_new_res %>%
            filter(year %in% c(yrs[length(yrs)])) %>%
            count(year, county) %>%
            group_by(year) %>%
            est_total("county", tot_res) %>%
            format_metric("participants - recruited") %>% format_grp("county")
    }
    
    # stack
    recruit_tbl <- bind_rows(recruit) %>%
        # round recruiticipants to nearest whole number, since fractions don't make sense
        mutate(value = round(value, digits = 0))
    rm(tot, tot_res, tot_residency, priv_new_res)
    
    # check
    # if (params$res_type != "nonres" & params$res_filter != "nonres") {
    #     est_total_check(recruit_tbl) %>% DT::datatable() # pct missing
    # }
} else {
    recruit_tbl <- data.frame()
}
```

### Churn

- Note: each "lapse" pct will be moved forward by one year, since current year churn is defined based on previous year lapse

```{r}
churn <- list()

churn[["tot"]] <- est_churn(priv) %>% format_metric("churn", "churn") %>% 
    mutate(segment = "All", category = "All")

churn[["sex"]] <- priv %>% est_churn("sex") %>%
    format_metric("churn", "churn") %>% format_grp("gender", "sex")

churn[["age"]] <- priv %>% est_churn("age") %>%
    format_metric("churn", "churn") %>% format_grp("age")

churn[["res"]] <- priv %>% est_churn("res") %>%
    format_metric("churn", "churn") %>% format_grp("Residency", "res")

if (params$res_type != "nonres" & params$res_filter != "nonres") {
    churn[["county"]] <- priv_res %>%
        filter(year %in% c(yrs[length(yrs)-1])) %>%
        est_churn("county") %>%
        format_metric("churn", "churn") %>% format_grp("county")
}
# rm(priv_res)

# stack for dashboard
churn_tbl <- bind_rows(churn)
DT::datatable(churn_tbl)
```

### License History

- Needed for both overall & recruits
- Counting total sales by month, so one person can show up mutliple times

```{r}
sale_new <- semi_join(sale, priv_new, by = c("cust_id", "year"))
sale_month <- list()

sale_month[["tot"]] <- count(sale, year, month) %>% 
    group_by(year) %>%
    format_metric() %>% format_grp("month")

# recruits - shown as their own metric
if (run_recruit) {
    sale_month[["recruit"]] <- count(sale_new, year, month) %>%
        group_by(year) %>%
        format_metric("participants - recruited") %>% format_grp("month")
}

sale_month_tbl <- bind_rows(sale_month) %>%
    mutate(category = as.character(category))
```

## Save

### Stack for Tableau

```{r}
if (params$res_filter == "nonres") {
    out_tbl <- part_tbl 
} else {
    out_tbl <- bind_rows(part_tbl, rate_tbl)
}
out_tbl <- bind_rows(out_tbl) %>%
    bind_rows(recruit_tbl) %>%
    bind_rows(churn_tbl) %>%
    bind_rows(sale_month_tbl)

type <- params$priv_nm # for allowing assignment to group variable to work correctly
out_tbl <- mutate(out_tbl, quarter = 4, group = type) %>%
    select(quarter, group, metric, segment, year, category, value)

# churn will likely be 10% smaller (except for county)
# recruited will likely be around 50% smaller (5 yrs can't be counted)
count(out_tbl, metric, segment) %>% spread(segment, n)
```

### Save Priv

```{r}
out_nm <- paste(params$priv_nm, params$res_filter, params$res_type, sep = "-") %>%
    stringr::str_replace_all("-NONE", "")

if (params$res_filter == "NONE") {
    if (!dir.exists(params$out_dir)) dir.create(params$out_dir)
    f <- file.path(params$out_dir, paste0(out_nm, ".RDATA"))
    save(out_tbl, file = f)
    glimpse(out_tbl)
}
```

### Save Participants

- Note: Participation lists are included for privilege rate calculation (where applicable)

```{r}
if (params$priv_ref == "NONE") {
    part_ref <- part
    if (params$res_filter != "nonres") part_ref[["county"]] <- part_res[["county"]]
    
    out_dir2 <- file.path(params$out_dir, "part")
    dir.create(out_dir2)
    f <- file.path(out_dir2, paste0(out_nm, "-part.RDATA"))
    save(part_ref, file = f)
    names(part_ref)
}
```
