---
title: "Introduction to salic"
output: 
    rmarkdown::html_vignette:
        toc: TRUE
vignette: >
  %\VignetteIndexEntry{Introduction to salic}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, include = FALSE, message = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7
)
library(dplyr)
library(salic)
```

## Overview

Salic provides a set of functions to progress from state license data to dashboard summaries. The workflow relies heavily on dplyr  (see [the dplyr intro](https://dplyr.tidyverse.org/)). You'll want to load both packages when using salic:

```{r}
library(salic)
library(dplyr)
```

This vignette walks through salic functionality using provided sample data. A function reference
can be accessed from `?salic`; it's organization mirrors this vignette.

## Standardized License Data

To facilitate a generalized workflow salic is strict about data formatting, and up-front effort is necessary to standardize the relevant state-level data. That said, the data needs are fairly light (9 variables total).

Salic specifies each table's formatting expectations (see `?cust`, `?sale`, and `?lic`). The 3 tables should be related by 2 key columns (cust_id, lic_id):

<br>
![](relations.png)

<br>
*Note that although residency (res) is a customer-level variable, it could conceivably change from year-to-year; hence the recommended sale-level specification.*

### Primary Keys

The `cust$cust_id` and `lic$lic_id` variables represent primary key columns (i.e., they must uniquely identify rows in the table):

```{r}
# load sample data
data(cust, lic, sale) 

# check customer ID
length(unique(cust$cust_id)) == nrow(cust)

# check license ID
length(unique(lic$lic_id)) == nrow(lic)
```

### Checking Formatting Rules

Salic helps you follow its formatting rules with `data_check()`. The function call is silent if all checks pass; warnings will be printed for every failed check.

```{r}
# prints no warnings
data_check(cust, lic, sale) 

# introduce rule-breaking changes
cust_tmp <- cust
cust_tmp$birth_year <- NULL
cust_tmp$sex[1] <- 3
data_check(cust_tmp, lic, sale)
```

### Categorical Variables

Salic expects specific numeric codes for categorical variables. For example, "sex" must be 1 of 3 values for every customer (1=Male, 2=Female, NA=Unknown):

```{r}
count(cust, sex)
```

### Sales: year & month

The "year" and "month" variables indicate the date of purchase (1 = Jan, 2 = Feb, etc.). 

```{r}
# sales by month in 2016
filter(sale, year == 2016) %>%
    count(year, month)
```

The month variable is needed for building "mid-year" dashboards, which present a year-to-year view for the first six months of sales.

```{r}
# count of customers (by year) who purchased in the first 6 months
filter(sale, year > 2015, month <= 6) %>%
    distinct(cust_id, year) %>%
    count(year)
```

### Licenses: type

The license table includes two columns important for customer trending. The "type" column specifies whether a license provides:

- a hunting privilege: "hunt"
- a fishing privilege: "fish" 
- or both: "combo"

```{r}
count(lic, type)

# count hunters for select years
filter(lic, type %in% c("hunt", "combo")) %>%
    inner_join(sale, by = "lic_id") %>%
    filter(year > 2015) %>%
    distinct(cust_id, year) %>%
    count(year)
```

### Licenses: duration

The "duration" column is necessary for building a license history. License types can be organized into 3 groups with respect to this variable:

- Multi-years: duration > 1 (2 = 2-year, 3 = 3-year, etc.)
- Lifetimes: duration = 99
- All others: duration = 1

```{r}
count(lic, duration)

# customers who buy 3-year licenses
cust_3yr <- filter(lic, duration == 3) %>%
    inner_join(sale, by = "lic_id") %>%
    filter(year > 2015) %>%
    distinct(cust_id, year)
count(cust_3yr, year)
```

## License History

The presence of multi-year buyers means that an extra step is needed to produce customer trends. This is accomplished in salic by calling `rank_sale()` & `make_history()` in sequence.

### Ranking Sales

The `rank_sale()` function is used as a preliminary step to reduce the sale table to 1 row per customer-year. It picks the row with the maximum duration value & optionally includes the earliest month value (for mid-year dashboards).

```{r}
# all hunting (non-combo) sales in 2016
sale_2016 <- inner_join(
    filter(sale, year == 2016),
    filter(lic, type == "hunt"),
    by = "lic_id"
)
count(sale_2016, duration, year)

# ranked hunting (non-combo) sales in 2016
rank_sale(sale_2016) %>%
    count(duration, year)
```

### Making License History

The `make_history()` function creates a larger table with 1 row for every year a license is held (i.e., both purchase years and "carried-over" license years are included). 

```{r}
# rank all sales
sale_ranked <- inner_join(sale, lic, by = "lic_id") %>%
    rank_sale()

# count customers who purchased a license in 2016
filter(sale_ranked, year > 2015) %>%
    count(year)

# count customers who held a license in 2016
make_history(sale_ranked, 2008:2018) %>%
    filter(year > 2015) %>%
    count(year)
```

Certain variables (e.g., sale$res) need to be included in the "carry_vars" argument of `make_history()` to ensure inclusion in carried-over license years. 

```{r}
# no residency information is included in the output by default
history <- make_history(sale_ranked, 2008:2018)
names(history)

# include residency
history <- make_history(sale_ranked, 2008:2018, carry_vars = "res")
filter(history, year == 2018) %>% count(res)

# customer-specific variables can be joined after make_history is run
left_join(history, cust, by = "cust_id") %>%
    filter(year == 2018) %>%
    count(sex)
```

### Lapse

A license history table makes it easier to look ahead (e.g., who lapsed?) or behind (e.g., who is a recruit?) at the customer level. The `make_history()` function appends 2 measures for this purpose. The "lapse" variable indicates whether a customer held a privilege in the following year (1 = lapsed, 0 = renewed):

```{r}
# build hunting privilege history
hunt <- filter(lic, type %in% c("hunt", "combo")) %>%
    inner_join(sale, by = "lic_id") %>%
    rank_sale() %>%
    make_history(2008:2018)
    
# hunters in 2016, what % lapsed in 2017? (i.e., churned)
filter(hunt, year == 2016) %>%
    count(year, lapse) %>%
    mutate(pct = n / sum(n) * 100)
```

### R3

The R3 measure is used to group license holders based on how recently they bought licenses:

- Retained: held a license last year
    + 1: carried over a license
    + 2: no carry-over
- 3: Reactivated: no license last year, but did hold one within past 5 years
- 4: Recruited: no license held within previous 5 years

```{r}
# hunters in 2016, what % are in each R3 group?
filter(hunt, year == 2016) %>%
    mutate(R3_label = factor_R3(R3)) %>%
    count(R3, R3_label) %>%
    mutate(pct = n / sum(n) * 100)
```

Note that R3 is set to missing for the first 5 years for a consistent definition of recruitment across time.

```{r}
filter(hunt, year %in% 2008:2013) %>%
    count(year, R3)
```

## Dashboard Metrics

The license history table provides a flexible data structure for summarizing customer trends. A set of specific summaries are needed for the AFWA national/regional dashboard; the following functions are included for this purpose.

### Preparation

Some initial preparation is needed to produce the summaries. Functions `label_categories()` & `recode_agecat()` are included for this purpose.

```{r}
data(history)

history <- history %>%
    label_categories() %>%
    recode_agecat() %>%
    filter(!agecat %in% c("0-17", "65+")) %>%
    select(cust_id, year, res, sex, agecat, R3, lapse)

# view history for 1 customer
filter(history, cust_id == 6120)
```

### Summarize Participants

The `est_part()` function produces a simple count of participants by year, either overall or broken out by a segment.

```{r}
# overall
part <- est_part(history, "tot")
filter(part, year > 2015)

# by gender
part_sex <- est_part(history, "sex")
filter(part_sex, year > 2015)
```

Because segments usually contain missing values, the `scaleup_part()` function is provided to peg segment percentages to total values.

```{r}
scaleup_part(part_sex, part) %>%
    filter(year > 2015)
```

### Summarize Churn

A similar function, `est_churn()`, is included for summarizing year-to-year turnover.

```{r}
filter(history, year > 2015) %>%
    est_churn("tot")
```

### Automating with apply

These summarization functions are designed with R's apply looping in mind:

```{r}
segments <- c("tot", "res", "sex", "agecat")

# store participant counts in a list of length 4 (1 per segment)
part <- sapply(
    segments, 
    function(i) est_part(history, i, test_threshold = 45), 
    simplify = FALSE
)

# view the first 2 rows of each segment
for (i in segments) {
    head(part[[i]], 2) %>% print()
    cat("\n") # include a blank row between printed tables
}
```

### Formatting the Summary Output

The apply-based approach produces lists, but we need a single table of summary data for input into the dashboard. The `format_result()` function is included to facilitate this.

```{r}
# pull overall participants from sample data
data(metrics)
part <- metrics$participants$tot
head(part, 3)

format_result(part, timeframe = "full-year", group = "all_sports") %>%
    head(3)
```

We can use apply to automate this final formatting:

```{r}
all_part <- metrics$participants
lapply(all_part, function(x) format_result(x, "full-year", "all_sports")) %>%
    bind_rows() %>%
    filter(segment == "Gender")
```

