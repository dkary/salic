---
title: "Introduction to salic"
output: 
    rmarkdown::html_vignette:
        toc: TRUE
    md_document:
        toc: TRUE
        variant: markdown_github
vignette: >
  %\VignetteIndexEntry{Introduction to salic}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, include = FALSE, message = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7
)
library(dplyr)
library(salic)
```

## Overview

Salic provides a set of functions to progress from license data to dashboard summaries. It also includes package dplyr on installation (see [the dplyr intro](https://dplyr.tidyverse.org/)). You'll want to load both packages when using salic:

```{r}
library(salic)
library(dplyr)
```

This vignette walks through salic functionality using provided sample data (see `?data_salic` for details).

## Standardized License Data

To facilitate a generalized workflow, salic is strict about data formatting, and some up-front effort is needed to standardize the relevant state-level data. That said, the dashboard data needs are fairly light (9 variables total in 3 tables).

Salic includes documentation about each table's formatting expectations (see `?cust`, `?sale`, `?lic` for details). The 3 tables should be related by 2 key columns:

![](relations.png)

### Formatting Rules

Salic helps you follow it's formatting rules with an included function (see `?data_check`). The function call is silent if all checks pass; warnings will be printed for every failed check.

```{r}
data(cust, lic, sale) # load sample data
data_check(cust, lic, sale)

# introduce some rule-breaking changes
cust$cust_id[1:2] <- 1
lic$type <- NULL
data_check(cust, lic, sale)
```


### Customers (cust)

Three customer columns are needed; "cust_id" being the most important. The cust_id should uniquely identify every row in the table (i.e., it's a primary key).

```{r}
data(cust)
glimpse(cust)

length(unique(cust$cust_id)) == nrow(cust)
```

Salic expects specific numeric codes for categorical variables. For example, "sex" must be 1 of 3 values for every customer (1, 2, or NA). You can view the corresponding labels using `salic::label_categories`.

```{r}
count(cust, sex)

label_categories(cust) %>% count(sex)
```

To assist standardization, salic includes functions to check your data against the formatting rules (see `?data_check_table`). The function call is silent if all checks pass; warnings will be printed for every failed check.

```{r}
data_check_cust(cust) 

# introduce some problems
tmp <- cust
tmp$cust_id[2] <- 1
tmp$birth_year <- NULL
data_check_cust(tmp)
```

### License Types (lic)

Three license type columns are needed. Similar to customers, license types should be uniquely identified using "lic_id".

```{r}
data(lic)
glimpse(lic)

length(unique(lic$lic_id)) == nrow(lic)
```

Unlike the customer table, no missing values are allowed in the license types table:

```{r}
tmp <- lic
tmp$type[1] <- NA
tmp$duration[1] <- NA
data_check_lic(tmp)
```

The "type" column specifies whether a license provides a hunting privilege ("hunt"), a fishing privilege ("fish"), or both ("combo").

```{r}
count(lic, type)
```

The "duration" column is necessary for building a license history. Specifically:

- Multi-year license are identified with values > 1 (e.g., 2 = 2-year, 3 = 3-year, etc.).
- Lifetimes are identified using a special value: 99.
- All other license types should = 1.

```{r}
count(lic, duration)
```

### License Sales (sale)

The license sales table includes 5 variables. No primary key is needed; the table links to customers and license types using foreign keys.

```{r}
data(sale)
glimpse(sale)
```

The "year" and "month" variables indicate the date of purchase (1 = Jan, 2 = Feb, etc.). The month variable is needed for building "mid-year" dashboards, which present a year-to-year view for the first six months of sales.

```{r}
# all customers per year
filter(sale, year >= 2015) %>%
    distinct(cust_id, year) %>% 
    count(year)

# customers in the first six months
filter(sale, year >= 2015, month <= 6) %>%
    distinct(cust_id, year) %>%
    count(year)
```

You can also make use of "type" to focus on hunters or anglers specifically. Note, that since the data contain combination licenses, we can't use a `group_by` operation directly for this purpose.

```{r}
filter(lic, type %in% c("hunt", "combo")) %>%
    inner_join(sale, by = "lic_id") %>%
    filter(year >= 2015) %>%
    distinct(cust_id, year) %>% 
    count(year)
```

The "res" variable identifies state residency for the customer. Storing this info at the transaction level provides additional flexibility since a person's residency status could conceivably change over time.

```{r}
count(sale, res)

label_categories(sale) %>% count(res)
```

## License History

START HERE

Also think about whether the above is too much of a data dump...it might be good to show the workflow that is needed earlier. There is a risk that people will begin reading and just give up.

### rank_sale


### make_history

#### R3

#### Lapse


## Dashboard Metrics

- filter by age
- `label_categories()` & `recode_agecat()`
- `est_part()`, `est_recruit()`, `est_churn()`

## Summary Output
